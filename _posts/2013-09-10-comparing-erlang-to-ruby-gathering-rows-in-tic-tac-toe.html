---
layout: post
title: 'Comparing Erlang to Ruby: Gathering Rows in Tic Tac Toe'
categories: []
tags:
- erlang
- recursion
- tic tac toe
status: publish
type: post
published: true
meta:
  _publicize_pending: '1'
author: 
---
<p dir="ltr">My first implementation of TTT in Ruby was pretty naïve, particularly my inflexible approach to collecting the contents of each square within a three-in-a-row. For example, <a href="https://github.com/pszals/learning_ruby/blob/7f6ba634d6fd309c2d37e15a5ec32f27ffc3eb4f/lib/board.rb">lines 60-67 </a>are simply a hard-coded aggregation of the eight possible combinations of three-in-a-row. If I wanted to make a 4x4 TTT I would have to create a separate list of combinations just for that. And if a client were to demand to be able to play TTT on any size board with a width from 3 to 300 (sometimes you just have to be zen and do things for the sake of doing them) then I would have to hard code 297 separate instances of winning combinations. Rather than burn out from repetitively simple rote tasks, I figured out a better way.</p>
<p dir="ltr">In this Ruby example, <a href="https://github.com/pszals/learning_ruby/blob/master/lib/ttt_rules.rb">lines 83-85</a> are analogous to the hard-coded <a href="https://github.com/pszals/learning_ruby/blob/7f6ba634d6fd309c2d37e15a5ec32f27ffc3eb4f/lib/board.rb">lines 60-62</a> in the previous example, except that this latter example will find all of the indices for a board of any width. To do the same thing in Erlang requires a bit of a different approach.</p>
<p dir="ltr">At the moment, <a href="https://github.com/pszals/erlang_ttt/blob/master/src/game_rules.erl">this bit of Erlang code</a> from lines 60-64 will take a board of 9 spaces and return a list of each of the rows. Thus, if we pass in an array like this [1,2,3,X,O,X,7,8,9] we will get: [[1,2,3], [X,O,X], [7,8,9]]. There’s a lot going on here, and if you don’t look closely enough, you might suspect that these five lines of code contain only one function, but if you look a bit more closely, you’ll see that there are actually TWO functions here.</p>
<p dir="ltr">What are those two functions, you ask? Erlang considers gather_rows/1 and gather_rows/2 to be two entirely different entities. The number after the slash is known as arity, or the number of arguments a particular function takes. The first function, gather_rows/1, takes a board object, currently represented by an array of 9 elements. What it returns, however, is not as simple as the [[1,2,3], [X,O,X], [7,8,9]] mentioned above. Instead, there is first a function call to the built-in function reverse/1 in the lists module that takes a list and reverses all of the elements in it. So we know that what comes into the function has to start out as [[7,8,9],[X,O,X],[1,2,3]]. This is the result of the function call gather_rows/2.</p>
<p dir="ltr">This function takes two arguments: the board, and an empty list. In Erlang parlance, the empty list is known as an accumulator -- it accumulates the results of a recursive algorithm. Because variables in Erlang are immutable, we have to figure out how to manipulate them without changing them. Thus, every time we “modify” the accumulator, we are not actually modifying it, rather we are creating an entirely different variable with the added information we put into it.</p>
<p dir="ltr">Notice on line 62 the two arguments that are being fed into gather_rows/2. An empty list, and a variable named Gathered (variables in Erlang must start with a capital letter). And what does it return? The variable Gathered, of course! But how the hell is that supposed to happen? The arguments we passed in originally were just the board, [1,2,3,X,O,X,7,8,9], and an empty list, [].</p>
<p dir="ltr">Enter, pattern matching. If an argument in a function head is a variable, it will accept whatever value you assign it when called. If an argument in a function head is an empty list, however, the argument entered when the function is called must also be an empty list. Therefore, when we pass in our board, which is NOT an empty list, the pattern does not match (i.e. [1,2,3,X,O,X,7,8,9] =/= []) and Erlang tries to match the next pattern, which WILL match because we have two variables (Rest and Gathered) in the function head that will be assigned the values we pass in. What does this function return? Another call to gather_rows/2! What is this devilish <a href="http://en.wikipedia.org/wiki/Ouroboros">ouroboros</a>??</p>
<p dir="ltr">Remember, as soon as the first argument is an empty list, the loop will terminate and release the information contained in the Gathered variable. The first argument on line 64 is a function call to another of Erlang’s BIF’s: nthtail/2. This is very similar to Ruby’s <a href="http://www.ruby-doc.org/core-2.0.0/Array.html#method-i-slice">slice!(start, length)</a> function. Erlang’s lists:nthtail(3, [1,2,3]) will evaluate to an empty list (hey, that’s what we’re looking for!), however lists:nthtail(3, [1,2,3,X,O,X,7,8,9]) will result in [X,O,X,7,8,9] -- that will be passed in as the first argument in the first recursive call of gather_rows/2.</p>
<p dir="ltr">The second argument will be the result of [lists:sublist(Rest, 3)|Gathered]. The lists:sublist/2 function is analogous to Ruby’s slice(start, length) function, which will return the elements in a list for the given parameters. In between the sublist function and the variable Gathered is a special character “|” (pipe), used for distinguishing the Head of a list from the Tail (snake reference number 2). In its current form, this list now has a new Head that has been prepended to the former Gathered list, and will be passed in recursively to assume the name Gathered again. Although this may look like we have overwritten the variable Gathered, upon further inspection you can see that we have called the function gather_rows/2 again, creating a new instance variable, Gathered, that exists in a parallel universe to the first. By prepending the combinations onto the front of the list we will end up with the backwards list that we wanted in the first place.</p>
<p dir="ltr">And now, we have come full circle (heh). After recursing through a couple times we end up spitting out the (backwards) gathered list of combinations we wanted in the first place because of the helpful pattern matching we set up. Then, by using the BIF reverse/1 we get [[1,2,3], [X,O,X], [7,8,9]]. And if you want to extrapolate this function for any size board, simply substitute the width of the board for the number 3.</p>
